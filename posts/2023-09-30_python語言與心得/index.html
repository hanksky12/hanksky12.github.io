<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Sky Blog | Python語言 與 工程師的職涯</title>
    <meta name="description" content="python語言 以前看到其他靜態語言的基礎觀念，在python裡面都不特別鼓吹，不懂也能開發，若不是 ">
    <link rel="canonical" href="https://hanksky12.github.io/posts/2023-09-30_python%E8%AA%9E%E8%A8%80%E8%88%87%E5%BF%83%E5%BE%97/" />
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <meta property="og:title" content="Python語言 與 工程師的職涯" />
<meta property="og:description" content="python語言 以前看到其他靜態語言的基礎觀念，在python裡面都不特別鼓吹，不懂也能開發，若不是" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hanksky12.github.io/posts/2023-09-30_python%E8%AA%9E%E8%A8%80%E8%88%87%E5%BF%83%E5%BE%97/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-30T16:29:23+08:00" />
<meta property="article:modified_time" content="2023-09-30T16:29:23+08:00" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python語言 與 工程師的職涯"/>
<meta name="twitter:description" content="python語言 以前看到其他靜態語言的基礎觀念，在python裡面都不特別鼓吹，不懂也能開發，若不是"/>

    
        
    

    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/md_nb.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/font-awesome-4.7.0/css/font-awesome.min.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
        <link rel="stylesheet" href='/css/comment.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />
    
    
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
         
    </style>
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
        <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    
    
        <script src='//cdnjs.cloudflare.com/ajax/libs/valine/1.5.0/Valine.min.js'></script>
    
    
    
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/md_nb.js"></script>
    <script src="/js/yes.js"></script>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">Sky Blog</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="/">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> Home</div>
                        </div>
                    </div>
                </a>
            
                <a href="/posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> Posts</div>
                        </div>
                    </div>
                </a>
            
                <a href="/categories">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> Categories</div>
                        </div>
                    </div>
                </a>
            
                <a href="/series">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-gears'></i> Series</div>
                        </div>
                    </div>
                </a>
            
                <a href="/tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> Tags</div>
                        </div>
                    </div>
                </a>
            
                <a href="/about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> About</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> Home
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> Posts
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> Categories
            </div>
        </a>
        
        <a href="/series">
            <div class="burger-item">
                <i class='fa fa-gears'></i> Series
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> Tags
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> About
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">








    <div class="hero">
        
            <div class="hero-img">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="" alt="">
            </div>
        
        <div class="hero-content">
            <div class="hero-title">Python語言 與 工程師的職涯</div>
            <div class="hero-subtitle"></div>
            <div class="hero-date">
                    <span class="no-wrap"><i class="fa fa-calendar"></i> postedOn: 2023-9-30 &nbsp;</span>
                    <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> updatedOn: 2023-9-30 &nbsp;</span>
                    <span class="no-wrap"><i class="fa fa-folder"></i>
                        includedIn:
                        
                            <a href='
                                /categories/%E6%89%8B%E6%9C%AD
                            '>
                                手札
                            </a>
                    </span>    
            </div>
            <div class="timelong">
                <span class="no-wrap"><i class="fa fa-pencil"></i> wordsCount: 807 &nbsp;</span>
                <span class="no-wrap"><i class="fa fa-clock-o"></i> readingTime: 2 mins &nbsp;</span>
                <span class="no-wrap"><i class="fa fa-eye"></i> viewers: <span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="content-root">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class="content">
            <div class="content-self">
                <h2 id="python語言">python語言</h2>
<p>以前看到其他靜態語言的基礎觀念，在python裡面都不特別鼓吹，不懂也能開發，若不是有機會在工作上接觸其他靜態語言，
其實很難去學通這些觀念，多型、封裝、抽象、介面..等等，而這些觀念對OOP是極為重要的，
回到python有一段時間一直想把動態語言寫成靜態語言，後來慢慢思考為何python會被創造，我為何喜歡使用python？</p>
<p>=&gt;簡潔，優雅，自由</p>
<p>其中自由也是初階開發者最大的問題</p>
<p>python的自由＝&gt;在需要時，可以適度的自我限制，在你不需要時，能用最簡單沒有被約束的方式完成</p>
<p>這是python易學難精的地方，靜態語言利用限制來強迫新手去遵守，寫出好的程式，
但python要寫出好程式，必須用適度的限制開發方式，才能做到，而這個適度又很彈性</p>
<p>一個靜態語言團隊沒有共同約束，2.3年內要維護和除錯應該還可以，
但如果是一個沒有約束的python團隊，程式的混亂程度，半年後可能難以維護(我也曾經是製造者，在有意識的察覺後，多花時間重構所有不洽當的程式)</p>
<h1 id="工程師之路">工程師之路</h1>
<h3 id="知道如何寫程式知道如何寫好程式知道如何架構出系統知道如何架構出好系統">知道如何寫程式=&gt;知道如何寫&lt;好程式&gt;=&gt;知道如何架構出系統=&gt;知道如何架構出&lt;好系統&gt;</h3>
<p>如果公司沒要求時，或是身處的環境不重視，會主動去追尋嗎？</p>
<p>當別的工程師以快速交付程式碼為傲，老闆或主管也不管程式的品質，能堅持做出好的東西嗎？</p>
<h1 id="定義一位好的工程師define-a-good-software-engineer">定義一位好的工程師(Define a good software engineer)</h1>
<p>面試官總是檢查你的硬技能 而不是 軟技能</p>
<p>也許大多數的公司不在乎這些，更在乎硬技能幫他們賺到的錢，而不是軟技能去幫他們節省下未來的錢</p>
<p>程式的寫法風格或架構的選擇沒有對錯問題，只有背後與未來所需要花費的價格問題</p>
<p>你自己必須去累積軟技能，才能稱得上是一個好的工程師 &ndash; by Hank</p>
<p>Interviewers always check your hard skills not your soft skills</p>
<p>Maybe most companies don&rsquo;t care about these, and care more about the money that hard skills can help them earn, rather than the soft skills that can help them save money in the future.</p>
<p>There is no right or wrong in the choice of program writing style or architecture, only the price behind it and the cost in the future.</p>
<p>You must accumulate soft skills yourself to be a good engineer  &ndash; by Hank</p>

            </div>
            
                <div class="tags">
                    
                    <span class="down-type-item">
                        <div class="type-text">
                            <a href='
                                        /tags/%E5%BF%83%E6%83%85
                                    '>
                                <i class="fa fa-tag"></i> 心情
                            </a>
                        </div>
                    </span>
                    
                </div>
            
        </div>
        
            
                <div class="pre-next">
                    
    
        
        <a href="https://hanksky12.github.io/posts/2023-09-30_python_flask/" class="pre">
            <span class="pre-icon"><i class="fa fa-hand-o-left"></i></span>
            <div class="pre-title-root">
                <span>Python Flask 架構</span>
            </div>
        </a>
        

        
        <a href="https://hanksky12.github.io/posts/2023-11-18_rabbit_and_pika/" class="next">
            <div class="next-title-root">
                <span>Message Queue[二] RabbitMq &amp; Pika Pika</span>
            </div>
            <span class="next-icon"><i class="fa fa-hand-o-right"></i></span>
        </a>
        

    
    

                </div>
            
        
    
</div>

    
        <div class="content-last">
            
                <button class="aixin content-last-item efct-button">
                    <i class="fa fa-heart"></i>
                </button>
            
            
                <button class="pinglun content-last-item efct-button">
                    <i class="fa fa-comment"></i>
                </button>
            
        </div>
    


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
            <div class="button-r">
                <button class="button-mulu efct-button" type="button"><span><i class="fa fa-bars"></i></span><span class="bars-text"> content</span></button>
                <button class="button-comment efct-button" type="button"><span><i class="fa fa-comment"></i></span><span class="comment-text"> comment</span></button>
            </div>
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/author.ico" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">HankSky</div>
            <div class="jianjie">
                Hello This World!
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /posts/
                '>
            <p>posts</p>
            <p>33</p>
        </a>
        <a href='
                    /categories/
                '>
            <p>categories</p>
            <p>2</p>
        </a>
        <a href='
                    /tags/
                '>
            <p>tags</p>
            <p>34</p>
        </a>
    </div>

    <a href="https://github.com/hanksky12?tab=repositories">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/hanksky12" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
        <a href="https://www.instagram.com/orz.iloveyou/" class="link-item is-hidden-desktop" title="IG">
            <span class="icon"><i class='fa fa-instagram'></i></span>
        </a>
        
    </div>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">Table of Contents</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            



    
    


<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">Related Posts</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="https://hanksky12.github.io/posts/2023-05-18_hello_world/">
                
<a href="https://hanksky12.github.io/posts/2023-05-18_hello_world/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Hello World
            </div>
            <div class="other-summary">Hello World! 就像每次學習新的語言， Hello world都是第一個印在console的字眼， 記得 第一次學習&gt;程式</div>
            <div class="other-date">2023-5-18</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hanksky12.github.io/posts/2023-08-12-courage_to_be_hated/">
                
<a href="https://hanksky12.github.io/posts/2023-08-12-courage_to_be_hated/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                被討厭的勇氣
            </div>
            <div class="other-summary">被討厭的勇氣:自我啟發之父「阿德勒」的教導 第一章: 決定論:亞里斯多德 過去的原因造成現在的我 目的論:阿</div>
            <div class="other-date">2023-8-12</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hanksky12.github.io/posts/2025_01_28_book_highlights/">
                
<a href="https://hanksky12.github.io/posts/2025_01_28_book_highlights/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                電子書重點整理
            </div>
            <div class="other-summary">總書單 致富覺察 多巴胺國度 勝算 快思慢想 晶片戰爭 給予 花掉的錢都會自己流回來 一個投機者的告白之金錢遊戲 一個</div>
            <div class="other-date">2025-1-27</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hanksky12.github.io/posts/2023-11-18_mq/">
                
<a href="https://hanksky12.github.io/posts/2023-11-18_mq/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Message Queue[一] Mq基礎
            </div>
            <div class="other-summary">MessageQueue(MQ) 訊息貯列，協助訊息以非同步方式溝通，常見協議MQTT,AMQP 訊息代理人 經紀人Broker 訊息發送</div>
            <div class="other-date">2023-11-18</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hanksky12.github.io/posts/2023-11-18_rabbit_and_pika/">
                
<a href="https://hanksky12.github.io/posts/2023-11-18_rabbit_and_pika/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Message Queue[二] RabbitMq &amp; Pika Pika
            </div>
            <div class="other-summary">緣由 在工作上，因為需要導入發布訂閱模式，故在幾種常見的Mq中做選擇 發布/訂閱 速度 訊息保證 訊息大小 訊息</div>
            <div class="other-date">2023-11-18</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            <div id="vcomments"></div>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: "BbBzDAiKcoWMhYtxAf4UQe2j-MdYXbMMI",
        appKey: "iBFYxS5U7Zno8VbVhCicaAaL",
        avatar: "robohash",
        placeholder: "输入你的想法",
        requiredFields: ["nick"],
        visitor:  true ,
        pageSize:  5 ,
});
</script>

        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>

    

<div class="sponsor">
    <div class="sponsor-self">
        <div class="sponsor-title">Sponsor</div>
        <div class="sponsor-btn">
            
                
                    
                        <div class="sponsor-btn-1 border-r">Wechat</div>
                    
                
                
            
                
                    
                        <div class="sponsor-btn-2 border-l">Alipay</div>
                    
                
                
            
        </div>
        
        <div class="sponsor-img">
            
                
                    <img class="sponsor-img-1" src="/images/sponsor/wechat.jpeg" alt="">
                
                
            
                
                    <img class="sponsor-img-2" src="/images/sponsor/alipay.jpeg" alt="" style="display: none;">
                
                
            
        </div>
        <div class="cancel efct-button">cancel</div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2023-2025 <a href="https://github.com/hanksky12?tab=repositories">HankSky</a>
                    </div>
                
                
            </div>
        </div>
    

    
        
    <div>
        <meting-js
            server = "netease"
            type = "playlist"
            id = "752439587"
            fixed = "true"
            autoplay = "false"
            loop = "all"
            order = "random"
            preload = "auto"
            list-folded = ""
            list-max-height = "500px"
            lrc-type = "1">
        </meting-js>
    </div>

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='Enter a KeyWord' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>search</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        









    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  33 ;
    var arrPosts = [{"link":"https://hanksky12.github.io/posts/2025_07_27_process_thread3/","plain":"共享資源 優點: 減少記憶體使用量，因為多個協程或線程可以用同一個資源。 提高速度，因為資源已經存在，而不會在需要時創建，結束後銷毀 缺點: 導致競爭條件，因為多個協程或線程可能同時訪問同一份資料，導致資料不一致。 程式碼可讀性和複雜度增加，因為需要考慮如何正確地管理和同步共享資源。(只對初學者是個困難點) 因共享的好處多於壞處，所以會去解決競爭問題=\u0026raquo; 通常會用鎖（Lock）來保護共享資源。 (Go 鼓勵用channel來傳遞資料，避免共享資源)\nRace condition競爭條件 指多個協程或線程同時訪問共享資源，導致資料不一致的情況。\n同時讀取和寫入共享資源。 同時修改共享資源的狀態。 A和B同時讀了資源=5，A要+2，B要+3，最後A以為資源是7，B以為資源是8，實際上不一定，這就是競爭條件。\nLock鎖 確保在同一時間只有一個協程或線程可以訪問共享資源。\nCritical section保護對象 指的是需要被保護的共享資源或程式碼區域。\n不一定某個值，可能是一段code需要有保證原子性\nLock的使用 在訪問共享資源之前，先獲取鎖。 在訪問共享資源之後，釋放鎖。 有上鎖，就必須解開，否則會導致其他協程或線程無法訪問共享資源，造成卡死。 在python中，通常使用with語句來自動管理鎖的獲取和釋放。\n在Go中，使用defer語句來確保鎖在函數結束時被釋放。\n因一次只能有一個協程或線程可以取鎖，如果只是要讀取，也要做競爭，效率低下，所以有讀寫鎖 Read Write Lock讀寫鎖 讀寫鎖允許多個協程或線程同時讀取共享資源，但在寫入時，會阻止其他協程或線程讀取或寫入。\n讀讀ok=\u0026gt;可多個拿讀鎖\n寫寫不ok=\u0026gt;只能有一個拿寫鎖\n讀寫不ok=\u0026gt;只能有一個拿寫鎖，讀鎖也不能取\n使用情境 主要是讀取，偶爾寫入時，使用讀寫鎖可以提高性能。 Dead Lock死鎖 當兩個或多個協程或線程互相等待對方釋放鎖，導致無法繼續執行的情況。\n四必要條件 Mutual Exclusion (互斥) 一個資源只能給一個人用 Hold and Wait (保持等待) 持有一個資源，並且正在等待其他資源。 No Preemption (不可搶奪) 資源不能被強制釋放，只能由自行釋放。 Circular Wait (循環等待) 存在互相等待的循環。 實例 A持有鎖1，等待鎖2。 B持有鎖2，等待鎖1，兩人都不放開，卡死 A先拿了讀鎖， 後續自己又要拿寫鎖，因為寫鎖會阻止其他讀鎖，所以A自己卡死自己 避免死鎖(破壞任一必要條件，各種方法) 一次性拿完所有要拿的鎖 使用超時機制，一定時間內沒有獲取到鎖，就放棄，手上的鎖也放掉 確保所有協程或線程按照相同的順序獲取鎖。 ","pubDate":"2025-07-27","title":"Process \u0026 Thread [三] Coroutines"},{"link":"https://hanksky12.github.io/posts/2025_07_27_stop_program2/","plain":"Go 實作Demo 單一goroutine的優雅停止，當接收到中斷信號時，能夠讓程式在完成當前任務後正常退出，而不是強制終止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; ) func main() { ctx, cancel := context.WithCancel(context.Background()) defer cancel() sigs := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) go func() { ticker := time.NewTicker(2 * time.Second) for { select { case \u0026lt;-sigs: fmt.Println(\u0026#34;接收到中斷信號，開始停止任務\u0026#34;) cancel() return case \u0026lt;-ticker.C: fmt.Println(\u0026#34;正在處理任務...\u0026#34;) } } }() fmt.Println(\u0026#34;全部服務已啟動\u0026#34;) select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;全部任務已停止，程式退出\u0026#34;) return } } 多個goroutine的優雅停止(server, worker, 訂閱, 排程, infinite loop\u0026hellip;) 使用廣播訊號來通知所有goroutine停止，並用wg 計算所有goroutine結束後再退出程式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; ) func main() { sigs := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) done := make(chan struct{}) var wg sync.WaitGroup // 多個不停止的併發(server, worker, 訂閱, 定期等) for i := 0; i \u0026lt; 5; i++ { wg.Add(1) go func(id int) { defer wg.Done() ticker := time.NewTicker(2 * time.Second) defer ticker.Stop() for { select { case \u0026lt;-done: fmt.Printf(\u0026#34;接收到中斷信號，任務 %d 開始停止\\n\u0026#34;, id) return case \u0026lt;-ticker.C: fmt.Printf(\u0026#34;任務 %d 正在處理...\\n\u0026#34;, id) } } }(i) } fmt.Println(\u0026#34;全部服務已啟動\u0026#34;) select { case \u0026lt;-sigs: close(done) // 廣播訊號給所有goroutine，如果只是單一goroutine，可以直接cancel wg.Wait() fmt.Println(\u0026#34;全部任務已停止，程式退出\u0026#34;) return } } ","pubDate":"2025-07-27","title":"優雅停止程式2"},{"link":"https://hanksky12.github.io/posts/2025_05_11_websocket/","plain":"緣由 因寫side project重新接觸到WebSocket，順便理清以前模糊的概念\n關於WebSocket Vs HTTP 一樣 都是應用層的協定 都是基於TCP的連線 都走在80/443 port 都有未加密版本ws:// http:// 和加密版本wss:// https:// 不一樣 WebSocket是雙向通訊(server可以主動向client)，HTTP是單向通訊 WebSocket是持久連線，HTTP是短暫連線 WebSocket是基於事件(OnOpen,OnMsg)，HTTP是基於請求 WebSocket是基於frame，HTTP是基於request/response 解決什麼問題? HTTP協定是單向，如果server端有事件要通知前端，只能等client端不斷的輪詢server端 而WebSocket是雙向的，初步建立連線後，後續的溝通是即時且不用重建TCP連線 建立連線 雖然協議是ws://或wss://，但實際建立連線是基於HTTP升級，所以port才會跟http相同\nClient端 client溝通時握手階段一定是http get方法，header裡面會有一個Upgrade的欄位和相關資訊(套件實作會自動帶) 因為是雙向溝通，也要定義當server傳事件OnOpen,OnMsg,OnClose,OnError的處理方式 Server端 server端啟動的時候，先啟動一個HTTP server，使用ws套件去定義當有ws請求時，對每種事件的處理方式OnOpen,OnMsg,OnClose,OnError 在特定路由get方法下，將HTTP請求轉換成ws請求，通常此時會將http get帶過來的身份驗證token內容放入ws內，提供後續OnOpen的使用 不管哪一個http路由升級成ws，在OnMsg的請求內是無法分辨從哪一個路由過來的，所以要自己去實作 因為是長連線，不用每個訊息都帶身份驗證 ","pubDate":"2025-05-11","title":"WebSocket"},{"link":"https://hanksky12.github.io/posts/2025_05_11_stop_program1/","plain":"緣由 因為工作加入新專案，看到對停止程式有專門做處理，才回頭思考自己對這部分的研究不足\n關於OS訊號 通常外部腳本，要停止process，首先應該用kill pid，其次才用kill -2 pid，最後才用kill -9 pid\n方法 訊號 說明 是否可攔截 建議用途 kill $pid SIGTERM (15) 預設，優雅關閉 ✅ 是 ✅ 首選 kill -2 SIGINT (2) 模擬 Ctrl+C ✅ 是 可選補救手段 kill -9 SIGKILL (9) 強制結束，無法攔截 ❌ 否 最後手段 kill -0 SIGCONT (18) 確認process是否存在 ❌ 否 用來確認process是否存在 sh腳本內使用 kill pid # 預設 SIGTERM，請求優雅終止 sleep 2 kill -2 pid # 若沒反應，可補發 SIGINT 看看 sleep 2 kill -9 pid # 最後手段，強制結束 程式內 在主要process啟動後，每個gateway跑在不同的thread執行(看語言)，所以應該在main thread中， 設置signal捕捉SIGTERM和SIGINT，後續通知給其他thread，讓他們優雅關閉\n何謂優雅關閉? 在thread中，有等待main thread的停止通知 收到通知後，將結束前的工作完成，可能是套件的stop調用或是自訂的業務邏輯 ","pubDate":"2025-05-11","title":"優雅停止程式"},{"link":"https://hanksky12.github.io/posts/2025_01_27_book_highlights_crawler/","plain":"緣由 因閱讀電子書，一直有畫重點的習慣，但官方提供的匯出csv或html，沒有排序，也有輸出總量的限制，html版面也呈現不出重點， 所以自己從爬蟲開始做了專案，將個人重點整理成html匯出。\n關於爬蟲 現代網站大多是動態網站，不是靜態，已經不是python request就能取得資料\n解法通常是\n透過API取得資料 透過模擬瀏覽器行為取得資料(selenium) 比較 抓取速度 開發複雜度 受前端版面影響 破解速度 debug 方便性 js 加密混淆影響 API取資料 快 高 沒有 慢 好 難度提高 模擬瀏覽器 慢 簡單 有 快 不好 沒有 從api取得資料，要去追蹤一個api所需的參數有哪些? 從哪裡可找到? 開發者工具是必須要熟練的， 而模擬瀏覽器，就是模擬人的操作行為，但速度慢，debug也不方便(不像api可以有response可直接觀察)， 其實還是有其技術經驗門檻，但卻是最暴力直接的方式，但前端只有小改一個tag，就可能讓爬蟲失效(看定位的依據)。\n個人觀點 從selenium出發，幾乎可以不用了解網站就能開始做爬蟲，但自己能寫過網站前後端後，才開始善用另一種方式， 爬蟲開發者如果要往上走，還是要了解網站的運作，才能更有效率的開發。\nGithub專案 用分析Api，獲取資料(login未實作，簡單從cookie拿取就可)\nhttps://github.com/hanksky12/EBooks\n","pubDate":"2025-01-27","title":"ReadMoo 電子書爬蟲"},{"link":"https://hanksky12.github.io/posts/2025_01_28_book_highlights/","plain":"總書單 致富覺察 多巴胺國度 勝算 快思慢想 晶片戰爭 給予 花掉的錢都會自己流回來 一個投機者的告白之金錢遊戲 一個投機者的告白之證券心理學 一個投機者的告白（增修版） 底層邏輯 底層邏輯2 ","pubDate":"2025-01-27","title":"電子書重點整理"},{"link":"https://hanksky12.github.io/posts/2024_11_23_kafka/","plain":"緣由 因為工作學了rabbitMQ，所以閒暇之餘來學kafka，想知道兩者的差異\n比較 速度 訊息保證 訊息大小 訊息量 消息留存 順序 重式機制 路由 消費者 rabbitMQ 稍慢 ACK 模式，確認拿走才刪 中 中 確認拿了，刪除不保留 不保證，失敗後會放回q，就亂了 內置重試邏輯和死信（dead-letter）交換器 可做篩選，再放入q 智能代理和傻瓜式消費者模式push kafka 有點慢 透過歷史紀錄重發送(消息日誌) 大 大 刪除大於 主題超時時間紀錄，在之內可以一直消費 最適用於數據的流式處理 自己寫，失敗可能會阻塞，or丟到retry topic 分區內所有都會接收，自己寫filter 傻瓜式代理和智能消費者模式pull 個人觀點 雖然兩邊本質都是發佈訂閱，但在技術實作上完全不相同，導致應用場景也不同，rabbitMQ適合短暫存放的訊息，訊息[推]給消費者後，就沒了，速度上也較快， 但kafka則是都寫到disk，用log的方式紀錄，消費者自己來[拉]，所以同樣的訊息，可以做重新消費，也可以同時有不同的app根據目的，同時消費， rabbitMQ的訊息主要在broker這邊做控制，消費者單純的收，kafka則是在消費者這邊做控制，根據自己的需求，去拉取訊息，所以在設計上，kafka的彈性較大，但也較複雜\n定義 分佈式流式平台，用於構建實時數據管道和流應用程序\n架構 Topic 生產者依據分類，將訊息送到不同的topic，消費者依據需求，訂閱不同的topic\n一個topic可以被0~n個消費者訂閱 一個topic可以被0~n個生產者發送 一個topic可以有1~n個partition，來存放msg 建立topic時，需要選舉，無法立刻發送訊息，因為沒有partition Partition 屬於topic，訊息積累的地方，一個partition內都是有順序，但不同partition間，沒有順序\n每個partition都有一個leader，多個follower，leader負責寫入，follower負責同步備份 訊息依照key值，分配到不同的partition(根據key的hash) 一個partition只被同一個group的一個consumer消費，但一個consumer可以消費多個partition Consumer 消費者，自己去拉取下訊息\n消費者可以屬於一個group 消費者可以消費多個partition 消費者可以自己控制offset，也可以讓kafka自己控制(GroupID) Offset手動Vs自動 自動控制offset，kafka會記錄每個消費者消費到哪裡，採取批次commit，可能因連線發生重複消費 手動控制offset，消費者自己記錄offset，可以用同步或異步 Consumer Group 消費者群組，因為某個目的，需要多個consumer去消費，所以group的概念出現\nProducer 生產者，將訊息送到topic\n因partition有備份，所以在消息確認ack上，有三種 0: 射後不理 1: 等待leader的ack all: 等待leader與follower的ack Broker 一個kafka server，真正放訊息的地方\nBroker Cluster 多個kafka server組成集群，提供高可用性，當一個Broker掛掉，其他Broker可以接手\nBroker Controller 負責管理broker，唯一，執行以下操作時，必須找Controller\n創造、删除topic 集群Broker管理（新增，關閉，故障) 增加，重分配partitionpublic 這篇blog寫的很好，可以參考 https://jiamaoxiang.top/2020/07/06/Kafka%E7%9A%84Controller-Broker%E6%98%AF%E4%BB%80%E4%B9%88/\nzookeeper 生產者，消費者，broker都要向他註冊\n紀錄meta msg，broker的狀態，topic的狀態，consumer的狀態\nApi種類 Producer(生產者): 將訊息發送到topic Consumer(消費者): 從topic消費訊息 Streams(流): 將topic的訊息處理後，再發送到topic Connect(連接器): 將topic的訊息處理後，再發送到外部系統 number of partitions and consumers 多餘的consumer會閒置 消費者可以同時消費多個partition 一個partition可以被多個consumer消費 ","pubDate":"2024-11-23","title":"Message Queue[三] Kafka"},{"link":"https://hanksky12.github.io/posts/2024_09_01_architecture_patterns_with_python/","plain":"Value Object 值物件 定義:單存資料，沒有特定身份，通常讓他不可變 兩個物件相等的條件是:所有值相等\npython 實作方式 dataclass\n例子:兩個10元硬幣，他們就是相等，不必在乎是否是同一枚硬幣\nEntity (reference Object) 實體(在POEAA書裡也稱為參考物件) 定義:有一個長期的持久性身份，值可變 兩個物件相等的條件是:持久性身份相等\n實作方式: id 欄位\n例如: 兩個人，身分證號碼相同，就判斷是同一人，不必在乎是否名字或其他資料相同\n","pubDate":"2024-09-01","title":"Architecture_Patterns_With_Python基礎概念"},{"link":"https://hanksky12.github.io/posts/2024_07_25_process_thread1/","plain":"前言 之前在工作上，已經運用多線程，協程，但對於底層運行，還不到通透的地步，重新整理知識\n基礎知識 Program 程式 用IDE寫好的code，沒有執行，只是一份沒啟動的檔案\nProcess 進程 管理資源的單位\n當啟動Program之後，讀入記憶體，cpu開始運行，這份程式會在電腦取得一份資源\nThread 線程 執行工作的單位(fake)\n在1個Process內，可能有1~n個Thread，最少1個n個Thread，否則就沒人來執行Process\nCPU 執行工作的單位(real)\n如果一次只能執行1個Thread，電腦就很難快起來，所以cpu將自己的時間切片，反覆在多個線程間切換，造成多工假象\n例子: 一家早餐店Process，至少要有一個虛擬員工Thread，雖然表面上是員工，但其實老闆cpu是要親自下來執行， 當老闆cpu要從虛擬員工Thread1切換到虛擬員工Thread2，虛擬員工Thread1紀錄要暫時封存， 並把虛擬員工Thread2的紀錄重新讀取，才能知道剛剛工作到哪裡 Multiprocessing 多進程 同樣的程式，想要加速，使用多進程會遇到資源的浪費，且切換效率很差，實務上盡量以多線程取代多進程\n好處是:資源絕對獨立，一個崩潰不會影響另一個\n例子: 為了讓做三明治產線加速，而另外開一家早餐店，老闆cpu要在兩家早餐店跑來跑去，很不划算 Multithreading 多線程 在同一個Process，使用多個線程，造成的問題是資源共享，為何資源共享是問題?\n好處是:會重複使用的資源可以放到共享，全域變數，靜態變數，減少開銷\n壞處是:也因這樣可能造成dead lock和race condition，一個線程沒處理好，會讓整個Process停住\n但只要注意好這些細節，在線程的切換上速度會比進程切換快\n例子: 同一家早餐店，烤麵包機器可以共享，但原料麵包總量也會共享，虛擬員工Thread1拿了一個，也會造成虛擬員工Thread2的原料麵包總量減少 Concurrent 併發 同一時間，只有一個任務在執行，但從整體來看，多個任務被細分，輪流執行一部分，造成多任務一起處理的假象， 這就是併發，單核心多線程的工作方式就是併發\nMultiCPU 多核心 真正會讓速度增加，只有增加多核心，多一個老闆Cpu，才能同一時間有第二個人一起辦公，cpu的分派，是由os負責， 並沒有一個cpu負責特定的Process或Thread，且2個cpu，也只能造成2個Thread同時執行，若有第3個，也會有部分併發\n例子: 多一個老闆Cpu，可以真正的增加工作效率 Parallel 並行 同一時間，真正有多個任務同時執行，才能稱作並行，只有多核心cpu才能做到\nCPU密集型 CPU-bound 必須靠cpu算力來決定任務速度的上限，單純的計算\nI/O密集型 I/O-bound 任務常常與cpu以外的硬體溝通，造成cpu閒置，主因還是cpu與其他硬體速度巨大落差， 任務速度的上限被等待回應的時間影響 ，例如:檔案存取，網路請求\nCoroutines 協程 在1個Thread內，建立多個Coroutines來做到任務分工，協程的切換開銷，又比Thread切換更小， 更適用於多任務的切換，但畢竟是在同一個Thread，所以是採用併發方式，適用於io bound， 遇到io需等待，就切換到其他任務，當所有任務都處於等待時，就會一直loop， 等到某個任務有回應可以繼續執行\n線程的切換由cpu決定，協程的切換由使用者來決定(在遇到io時，切換Coroutines)，所以可以自己控制 關鍵資源，避免同一個Thread內會遇到的共用資源競爭問題\n結論:要高性能處理任務 CPU-bound任務:多線程開發(多核心)(Parallel)\nI/O-bound任務:多協程開發(Concurrent)\n多進程還是有它的好處，每個都是獨立不互相影響，一個崩潰了，其他能正常運行也是可以看開發目的做使用\n","pubDate":"2024-07-25","title":"Process \u0026 Thread [一]"},{"link":"https://hanksky12.github.io/posts/2024_07_25_process_thread2/","plain":"Python Global Interpreter Lock 一個GIL鎖，主要是在Cpython的解釋器上，在每個進程生成時，會有一個解釋器負責解釋 ，對多線程有一把鎖，限制同時間只能有一個線程工作，用計數方式，釋放後，所有線程重新競爭GIL，或是遇到io主動釋放\n多核心多線程任務 CPU-bound 單進程 CPU-bound任務，想要節省資源，基本會用單進程，但這個解釋器，不管是多核心，或多線程，一次只能讓一個線程工作\n例子 類似掃地或擦桌子這種任務，必須持續的做，不做就沒進度，但工作到一半，又會被GIL叫停，回來搶鎖再繼續工作 多進程 可以解決CPU-bound的問題，因為讓每個進程有自己的鎖 缺點:代價是資源的消耗，以及要另外創建資源來做跨進程的溝通\n例子 I/O-bound 在io任務中，因GIL遇到io會主動釋放，所以反而適用\n協程 在python中雖然多協程，可以最大化降低開銷，但要主動去做切換，而多線程的切換，是交給電腦處理， 所以在I/O-bound任務如果太複雜，也可以用多線程來實作，更多時候，可以視情況混合使用\n結論:要高性能處理任務 CPU-bound任務:多進程\nI/O-bound任務:多協程，多線程\n","pubDate":"2024-07-25","title":"Process \u0026 Thread [二]"},{"link":"https://hanksky12.github.io/posts/2024_06_09_poeaa_layer/","plain":"分層 在不管是軟體的開發或硬體架構，分層的作法到處都是，雖然分層讓層與層之間，多了一個轉換的動作， 但一個標準去隔離不同層的屬性，每一層的任務單一，在除錯上，很快就能鎖定對象位置\n三層 展示層 處理使用者與軟體的互動，向使用者展示資訊，將使用者命令網領域層傳遞 在桌面程式，就是使用者介面的控制 在網站後端中，就是路由位置\n領域層 商業邏輯的位置，真正的核心\n資料來源層 與其他系統的通訊，主要是資料庫，這裡也說到MQ也算是\n個人看法 目前程式內不管是後端，定期程式，消費者，都可以區分這三層，這些概念與寫哪一種程式無關，自己回顧以前寫桌面應用時， 其實就已經不自覺地開始去區分Ui和邏輯層，但在不同公司不同專案，可能都有不同分法或層數，但有去做區分，一定比完全不區分好， 之後會更好維護\n","pubDate":"2024-06-09","title":"PoEAA Layer分層"},{"link":"https://hanksky12.github.io/posts/2024_04_28_storage/","plain":"儲存類型 區塊block 檔案file 物件object 儲存層次(從底層到抽象) 區塊block \u0026lt; 檔案file \u0026lt; 物件object\n區塊儲存block storage 適合使用者:系統(作業系統，虛擬機，資料庫) 架構:Volume，LUN 協議:SCSI，iSCSI，STAT，NVMe，FC 是所有儲存類型的根本 資料切割放在區塊中 用LBA定位，區塊大小固定 沒有元數據 適合結構性資料 高效率，高頻率 更新資料的一部分，只會更新對應區塊 ex:SAN 檔案儲存file storage 適合使用者:人類用戶 架構:階層式，樹狀 協議:SMB(windows)，NFS(linux) 資料用檔案呈現 適合人類操作 ex:NAS 物件儲存object storage 適合使用者:應用款體 架構:key-value 協議:Restful http 扁平式，無階層 資料用物件呈現 適合非結構性資料 擴充性強 更新資料的一部分，就要更新整個物件 ex:aws s3,ali cloud oss ","pubDate":"2024-04-28","title":"Storage [一] 基礎"},{"link":"https://hanksky12.github.io/posts/2024_04_28_storage2/","plain":"阿里雲Oss 阿里雲的物件儲存服務，因公司主要使用阿里雲，所以從Oss介紹一些名詞，其他家應該也差不多\nBucket儲存桶 每個用戶，可以創建多個儲存桶，每個桶子內的物件key必須是唯一\nObject物件 以key來當索引，純字串，可用\u0026quot;abc/123.jpg\u0026quot;來表示， 雖然用雲服務提供的軟體會看到資料夾的層次，但實際上並沒有資料夾的概念，對 \u0026ldquo;abc/123.jpg\u0026quot;和\u0026quot;abc/fgh/ert/yty/123.jpg\u0026quot;是一樣的搜索效率，每次的更新就是整個物件\nRegion域 建立bucket時，要先選擇bucket的實際物理位置，看要提供的user在哪一區，選擇較近的國家， 建立bucket後，就無法更改\nEndpoint 提供操作物件的域名，在Oss還區分內網與外網，內網專門給Oss的ECS使用，不收流量费， 限制是ECS與bucket在需同Region下，並且使用內網來操作物件\nOssFs 與 CSG 兩者都同樣是讓oss可以用檔案系統的方式掛載在ECS，讓使用者以操作本地資料夾方式使用， 但CSG要收費，OssFs不用，CSG是以NAS方式做到掛載，而ossFs是用Filesystem in Userspace， 去自實現檔案系統與oss的操作對應，所以ossFs有著FUSE的常見問題，不合適大量讀寫，在官方文件裡面， 都有特別列出差異\nhttps://help.aliyun.com/zh/csg/product-overview/csg-software-edition-in-public-preview#task-2100660\n費用 儲存(基本)+流量(別人點擊)+請求(操作物件)+其他有使用才付費\nhttps://help.aliyun.com/zh/oss/product-overview/billing-overview?spm=5176.7933691.J_4109997320.2.4db92c47IdFmb8\n開發 提供各語言SDK，最多做到線程級別的併發，若要做到python的協程，則要自己打底層api+做出簽名\nhttps://www.alibabacloud.com/help/tc/oss/developer-reference/description\n","pubDate":"2024-04-28","title":"Storage [二] Object Storage"},{"link":"https://hanksky12.github.io/posts/2024_03_24_cors/","plain":"緣由 在工作上，因為整體設計分散式架構和前後端分離，所以有一個前端，對多個後端服務，一個網域的cookie，需要能帶到 不同送後端上，故有了cors cookie的需求\n基本認知 以下討論都是在瀏覽器上的限制，如果是自己寫程式，或postman，服務間的呼叫都不受限，這是初學者可能會忘了的一點\n同源政策Same Origin Policy 基本邏輯是同一個源的前後端才能互相溝通\n目的 保護網站資源不被第三方利用\n請求需同時滿足所有同源條件 http or https domain port 上面三個前端與請求後端都需要一致\n同源允許與限制 允許HTML tag產生的跨來源 write/embed/read 限制Js產生的跨來源 write/embed/read cookie的同源 同源只需滿足domain和path一樣，即是同源 子網域可以操作母網域的cookie\n","pubDate":"2024-03-24","title":"Cors [一]同源政策"},{"link":"https://hanksky12.github.io/posts/2024_03_24_cors2/","plain":"基本認知 以下討論都是在瀏覽器上的限制，如果是自己寫程式，或postman，服務間的呼叫都不受限，這是初學者可能會忘了的一點\n跨網域資源共享Cross-Origin Resource Sharing 不同源的網站資源要在同源限制下互相利用\n目的 從第一篇同源的限制可知道，主要限制的是js的write/embed/read， 故cors主要就是在特定條件下，讓瀏覽器知道這是可信任的操作\n如何做到? 透過在resp header加上訊息讓瀏覽器做判斷，在後端來做或webserver添加都可以，但只能擇一\n簡單請求simple requests HEAD、GET、POST 方法其中之一 HTTP 的 header 限制為： Accept Accept-Language Content-Language Last-Event-ID Content-Type 只能是 application/x-www-form-urlencoded、multipart/form-data、text/plain 方式 添加一個resp header\nAccess-Control-Allow-Origin 非簡單請求 超過上述的限制後，瀏覽器在真正請求前，會打預請求preflight request，來判斷真正請求是否發出，所以會依序送出兩種請求\npreflight的方法是OPTIONS\n非簡單請求常見的方法是PUT,DELETE\n方式 添加三個resp header\nAccess-Control-Allow-Origin Access-Control-Allow-Methods Access-Control-Allow-Headers cookie 以下是常見的老舊範例XD 在設定上分為前端，原本後端，跨站的後端\n\u0026lt;前端:\u0026gt; fetch=\u0026gt;credentials: \u0026ldquo;include\u0026rdquo; axios=\u0026gt;withCredentials: true\n\u0026lt;原本後端:\u0026gt; 在Chrome 80之後 要設定same site=None + 掛https\n\u0026lt;跨站的後端:\u0026gt; Access-Control-Allow-Credentials = true\nCorsDemo 工作上遇到問題，發現cors請求已經通過，但是在cors cookie上，Chrome帶不上去，所以寫一個小專案來檢查問題 https://github.com/hanksky12/CorsPratices\n後來發現即使是這個原形專案，cookie還是無法從Chrome帶到跨站的後端，2024以前滿足上面的條件就能帶上cookie， 但2024開始Chrome逐漸禁用第三方cookie，而我剛好是前幾批次被挑中的人，所以我的browser已經無法帶第三方cookie， 簡單的說就是換了一種更嚴格的方式來實作cors cookie\n後來去思考為何第三方cookie，越來越難實作，我覺得根本性原因是同公司的網站，本來去採用同一個網域去面對瀏覽器才是合理的配置， 故自己最後選擇用nginx來反向代理所有後端，讓瀏覽器面對單一網域也簡化了問題\nRelated Website Sets 2024之後實作cors cookie，需要到google chrome github，提交自己的原站與跨域站，發PR讓他們做審核通過\nhttps://developers.google.com/privacy-sandbox/3pcd/related-website-sets?fbclid=IwAR21Uy23UfmxMoQ6ZbXgeW9qHeWOYFc-_lQQBB3Pj_vWK34ASz8FHVIaATg\nhttps://github.com/GoogleChrome/related-website-sets/blob/main/RWS-Submission_Guidelines.md?fbclid=IwAR3-kQAUCaKNF-VVWEXE0_vyVTUcZ4oo4djZdQpICo7cp4OfGfs0sFkpbqI\n","pubDate":"2024-03-24","title":"Cors [二]跨網域資源共享"},{"link":"https://hanksky12.github.io/posts/2024_02_17_olympus_camera/","plain":"緣由 自己的相機Olympus，平常要讀取照片，通常用電腦直接讀取sd記憶卡，\n這次在mac筆電上想看照片，但又沒辦法讀取sd，\n因為相機有支援wifi功能，在手機或平板也是使用官方OM Image Share app做圖片讀取，\n但mac無法安裝app，於是動手寫了一個小專案從wifi連線進入抓圖\n實作方式 主要參考這篇文章，發現連上wifi後，可以從瀏覽器進入http://192.168.0.10，連入相機的內部後端網站， 平常提供給官方app連線\n但是沒有提供任何的多圖下載功能，只能單張右鍵下載，所以寫一個python小專案，用asyncio+爬蟲的方式將大量圖片抓回電腦\n有意思的地方 因為是相機的內部，所以被鎖定最大連線數只能為2\n這點跟平常的後端網站的差異巨大，畢竟相機的core不能跟電腦的core相比，所以在這邊即使採用coroutine，速度也是很慢\n近年新款的機型不知道連線數會不會支援更多？\nGithub https://github.com/hanksky12/OlympusCameraImage\n","pubDate":"2024-02-17","title":"Olympus Camera"},{"link":"https://hanksky12.github.io/posts/2024_01_27_celery2/","plain":"任務定義 將裝飾器綁到函數\ncelery = Celery(__name__,broker=broker) @celery.task def add(x: int, y: int) -\u0026gt; int: time.sleep(5) return x + y add 就是一個task 任務使用 完整版 apply_async(args[, kwargs[, …]]) ex: add.apply_async(args=[arg1, arg2], kwargs={\u0026#39;kwarg1\u0026#39;: \u0026#39;x\u0026#39;, \u0026#39;kwarg2\u0026#39;: \u0026#39;y\u0026#39;},countdown=10)) 簡化版(不帶選項類型參數=\u0026gt;控制任務) delay(*args, **kwargs) ex: add.delay(arg1, arg2, kwarg1=\u0026#39;x\u0026#39;, kwarg2=\u0026#39;y\u0026#39;) Signatures 簽名=⇒將函數當成可傳遞 完整版 add.signature((2, 2), countdown=10) s = add.signature((2, 2), {\u0026#39;debug\u0026#39;: True}, countdown=10) 可印出的方式 s.args (2, 2) s.kwargs {\u0026#39;debug\u0026#39;: True} s.options {\u0026#39;countdown\u0026#39;: 10} 簡化版(不帶選項類型參數=\u0026gt;控制任務) add.s(2, 2, debug=True) 簡化外掛版又加上參數 add.s(1, 2, debug=True).set(countdown=5) 為何要有簽名？ 直接啟動任務，不就可以執行？還要先變成可傳遞，再去調用一次\n因為要讓多個任務可以組合\nTask Flow(Primitives) 對多個任務的組合方式\n組合方式 group 一次等多個任務結束後，才回傳 chain 任務一個接一個 chord group + callback任務 map 一個任務，處理多個不同參數，一次回傳多個結果 starmap 同map，參數帶入(tuple) chunks 將可迭代參數自動區分成多個小任務 提醒: 阻塞 在celery 一個任務內，不可做其他任務等待，不能用阻塞的方式，所以chord才用callback，而rpc不會存結果，在這邊不能當後端使用\n阻塞類型的定期程式 有阻塞類型的定期程式，就不能用beat，因為beat的啟動就是把定期本身當成一個任務丟出去到worker 必須改用APScheduler的定期在裡面手動丟給celery任務\n","pubDate":"2024-01-27","title":"Task queue[三] Celery(二)"},{"link":"https://hanksky12.github.io/posts/2024_01_27_celery/","plain":"緣由 在工作上，遇到單機已經過多負荷，所以開始做實作分散式爬蟲\nCelery定義 分散式任務隊列處理\n架構 任務發啟=\u0026gt;Broker=\u0026gt;Worker處理任務=\u0026gt;Result Backend(有需要再回傳)=\u0026gt;任務結果\n任務傳送 Broker 可選RabbitMq,Redis,\u0026hellip;..\n必需決定的就是Broker的選用，建議學習RabbitMq，開發快速選Redis， 但作者是採用RabbitMq的術語來當作參考，如有需要進階設定，還是要了解\nResult Backend 可選關聯式DB,Redis,rpc(回傳但不存)\n無需結果回傳，就不需選擇\n任務發起 Beat 定期任務發起的process\n手動 在程式內調用\n任務處理 Worker 處理任務的process\n所有任務分發都經過這個主要的process，再做併發\n任務監控 Flower 任務的監控網站\n任務的搜尋 要看一下官方範例，比較容易了解，網站寫的簡略\nhttps://github.com/mher/flower/blob/master/tests/unit/utils/test_search.py\n可經由nginx反向代理到外部，可簡單設定使用者驗證，可與prometheus和grafana結合\nworker 參數 -n 命名\n-l log等級\n\u0026ndash;logfile 指定log位置與檔名，檔名會參考worker的命名\n-c | \u0026ndash;autoscale 指定併發數 ｜ 基礎併發數與最大併發數\n如果使用autoscale，偵測到不足才會去scale啟動比較慢\n-P 預設併發是 multiprocessing，可以改thread或Coroutine(支援gevent)，看任務取向，io類型用gevent， 不用自己寫async/await，使用簡單，官方範例https://github.com/celery/celery/tree/main/examples/gevent\n-Q 接收特定queue的任務，可指定多個\n","pubDate":"2024-01-27","title":"Task queue[二] Celery"},{"link":"https://hanksky12.github.io/posts/2024_01_26_tq/","plain":"TaskQueue \u0026amp; MessageQueue 傳送物件 抽象層級 主要設定 相同 Tq 任務 高(基於mq的封裝) 任務的使用方式與處理 異步與分散式 Mq 訊息 低 訊息的傳送對象與傳遞方式 異步與分散式 白話介紹 Tq是在Mq上再次開發，省略底層細節(還是可藉由參數控制Mq設定)，所以會有Mq的角色在底層協助，不用去指定任務要到哪裡去處理，而是聚焦在如何處理\n工具解決目標 網站的長時間任務，或定期的高併發任務須要做分散式處理\n常見的Tq有Python Celery,Go Machinery\u0026hellip;\n任務代理人 經紀人Broker(就是Mq的Broker)\n任務發送者 網站 或 定期程式\n任務接收者 工人Worker(就是Mq的Consumer)\n任務 在queue傳送的主要對象都是任務，可夾帶參數，可回傳結果，因通常在高併發場景，所以盡量降低網路間傳送的資訊量，在worker才去取需要的資訊， 或者在worker就把任務處理完成，不必回傳結果\n","pubDate":"2024-01-26","title":"Task queue[一] Tq基礎"},{"link":"https://hanksky12.github.io/posts/2023-11-18_mq/","plain":"MessageQueue(MQ) 訊息貯列，協助訊息以非同步方式溝通，常見協議MQTT,AMQP\n訊息代理人 經紀人Broker\n訊息發送者 生產者Producer\n訊息接收者 消費者Consumer\n常見的直接溝通，轉換為間接溝通 發送後就等待請求，必須等待請求者接收訊息並處理才回覆，在Mq加入後，解耦合了發送者與接收者\n所以 Mq常被稱為代理人Broker，而發送者也不再面對接收者，轉為訊息的Producer，接收者轉為訊息的Consumer\n優勢 生產者不用等待消費者處理完成，非同步，如果是網站後端，可以將長時間任務解耦合出去，提早給網站使用者回覆 原本一對一的溝通，可以因為加入Mq，採用Topic的方式，一次對多個Consumer溝通 在符合MQTT的Mq中，通常訊息比HTTP協議夾帶更小量資訊，在IOT領域，節省很多資源 在符合AMQP的Mq中，加入exchange角色，讓訊息發布方式可以更複雜，訊息可以暫存 缺點 在多個微服務裡面，一件完整的業務，被用Mq解耦合後，如果中途失敗，要如何保持整件事情的交易完整性，是需要思考的 在系統未到需要Mq的情況下，提前引入Mq當代理，反而提升了整體複雜度 在系統的穩定度上，多了一個不確定的因素 ","pubDate":"2023-11-18","title":"Message Queue[一] Mq基礎"},{"link":"https://hanksky12.github.io/posts/2023-11-18_rabbit_and_pika/","plain":"緣由 在工作上，因為需要導入發布訂閱模式，故在幾種常見的Mq中做選擇\n發布/訂閱 速度 訊息保證 訊息大小 訊息量 redis 快 沒有 小 小 rabbitMQ 稍慢 ACK 模式，確認拿走才刪 中 中 kafka 有點慢 透過歷史紀錄 大 大 RabbitMq 基於AMQP協議\nSimple 模式 producer將massage直接放到queue，一位consumer去消費\nWorker 模式 同Simple模式，但是改為多位consumer去消費，其中一位拿走，訊息就沒了，常見於分散式爬蟲的目標網址， 這邊還可以設定欲取數量\nPublish/Subscribe 模式 producer將massage送到exchange，藉由多個queue去綁定到exchange，一次送給多個queue，每個queue對應一位消費者\nRouting 模式 同Publish/Subscribe模式，多加了訊息的走向篩選機制\n加入了routing key概念，producer發送時加入routing key，每個queue在綁定到exchange同時\n先宣告自己要監聽的routing key，讓exchange可以知道訊息應該發送到哪些queue，篩選機制是要完全match的，才會送達\nTopics 模式 同Routing模式的升級版，篩選機制改用模糊比對\nRPC模式 在原producer發送訊息前，先定義要回傳的queue與關聯id，發送後，producer轉為consumer等待[處理後的訊息]回傳\n在原consumer收到訊息後，對訊息做處理後，轉為producer，並根據要回傳的queue與關聯id，傳送[處理後的訊息]\nhttps://github.com/hanksky12/RabbitMQ_Tutorials\nPort :5672 server :15672 後台\nExchange 交換機 決定訊息走向的人，單純做篩選，訊息不停留在此\nQueue 貯列 會將訊息累積的人，當消費者不在線上或還未消費的，訊息會積累在此\nAck 機制 可以在訊息處理完，決定此訊息是否已經消費完成，\n用ack確認處理成功，或nack代表訊息接下來的走向，返回queue重新排隊，或者丟棄此訊息\nDead Letter 死信機制 Why 死信要處理？\n當處理訊息失敗，應該直接丟棄？\n或重回queue排隊，可能一直每次失敗，導致漸漸阻塞queue\n死信條件: 訊息在queue上面超過max可停留時間 訊息在queue上面超過max訊息數量 消費時，使用nack或reject 當上面發生時，訊息會由queue去到死信交換機，死信exchange和queue與普通的一樣， 只是看在死信的消費者想要如何統一處理這些訊息\n這邊要注意的是，死信的如何處理，由每個的queue去決定，不互相干涉\n會刪除的queue 在rabbit mq裡面只有兩種機制\n在宣告queue的同時，設定auto_delete=True 使用臨時queue，消費後，自動刪除 使用這兩種queue，都會導致消費者離線後，如果exchange還有送new message，會直接消失\nHeartbeats 在pika要特別注意，沒有實作重連機制，且客戶端與server端間，有心跳檢測，如果太久沒收到，會關閉Tcp連線， 導致訊息要送的時間跳出ConnectError，所以要try except，去自動重連， 在宣告連線參數時，可以設定HeartbeatsTimeOut，官方不建議設0(不檢測)，不是真正解決問題\n","pubDate":"2023-11-18","title":"Message Queue[二] RabbitMq \u0026 Pika Pika"},{"link":"https://hanksky12.github.io/posts/2023-09-30_python%E8%AA%9E%E8%A8%80%E8%88%87%E5%BF%83%E5%BE%97/","plain":"python語言 以前看到其他靜態語言的基礎觀念，在python裡面都不特別鼓吹，不懂也能開發，若不是有機會在工作上接觸其他靜態語言， 其實很難去學通這些觀念，多型、封裝、抽象、介面..等等，而這些觀念對OOP是極為重要的， 回到python有一段時間一直想把動態語言寫成靜態語言，後來慢慢思考為何python會被創造，我為何喜歡使用python？\n=\u0026gt;簡潔，優雅，自由\n其中自由也是初階開發者最大的問題\npython的自由＝\u0026gt;在需要時，可以適度的自我限制，在你不需要時，能用最簡單沒有被約束的方式完成\n這是python易學難精的地方，靜態語言利用限制來強迫新手去遵守，寫出好的程式， 但python要寫出好程式，必須用適度的限制開發方式，才能做到，而這個適度又很彈性\n一個靜態語言團隊沒有共同約束，2.3年內要維護和除錯應該還可以， 但如果是一個沒有約束的python團隊，程式的混亂程度，半年後可能難以維護(我也曾經是製造者，在有意識的察覺後，多花時間重構所有不洽當的程式)\n工程師之路 知道如何寫程式=\u0026gt;知道如何寫\u0026lt;好程式\u0026gt;=\u0026gt;知道如何架構出系統=\u0026gt;知道如何架構出\u0026lt;好系統\u0026gt; 如果公司沒要求時，或是身處的環境不重視，會主動去追尋嗎？\n當別的工程師以快速交付程式碼為傲，老闆或主管也不管程式的品質，能堅持做出好的東西嗎？\n定義一位好的工程師(Define a good software engineer) 面試官總是檢查你的硬技能 而不是 軟技能\n也許大多數的公司不在乎這些，更在乎硬技能幫他們賺到的錢，而不是軟技能去幫他們節省下未來的錢\n程式的寫法風格或架構的選擇沒有對錯問題，只有背後與未來所需要花費的價格問題\n你自己必須去累積軟技能，才能稱得上是一個好的工程師 \u0026ndash; by Hank\nInterviewers always check your hard skills not your soft skills\nMaybe most companies don\u0026rsquo;t care about these, and care more about the money that hard skills can help them earn, rather than the soft skills that can help them save money in the future.\nThere is no right or wrong in the choice of program writing style or architecture, only the price behind it and the cost in the future.\nYou must accumulate soft skills yourself to be a good engineer \u0026ndash; by Hank\n","pubDate":"2023-09-30","title":"Python語言 與 工程師的職涯"},{"link":"https://hanksky12.github.io/posts/2023-09-30_python_flask/","plain":"flask網站開發 之前讀過這本O\u0026rsquo;Reilly的 Flask Web Development(2 Ed.)，就很喜歡裡面建構大型應用的方式，可擴展性很高，\n雖說flask主打輕巧易用，但有意識的建構下，也可慢慢建構成與Django相抗衡的網站，且套件和建構的選用也更自由，\n例如 如果想把網站以DDD方式建構，Django就完全做不到，\n為了真正做到好維護，方便以後擴展性的網站 ，也去參考其他靜態語言常用框架的分層結構，發現java或C#(尤其是C#)，分層真的多， 引入各種值物件的定義與介面，來解耦和各種分層\n若以python想去模擬靜態語言的web框架方式，會去違背我最喜歡的python精神=\u0026gt;「優雅」、「明確」、「簡單」，\n最後決定以廣義分層架構，來實作後端api，既不會過多的分層，但也適度的做出分類\nhttps://github.com/hanksky12/scalability_flask/tree/main/backend\napp config const controller api topic1 topic2 main models schemas fields schemas services exceptions interface utils web run_app.py ","pubDate":"2023-09-30","title":"Python Flask 架構"},{"link":"https://hanksky12.github.io/posts/2023-09-16_python_logging/","plain":"前言 最近工作上碰到自己的需求，想在定期專案中，對多線程中，同類型放同一個檔案，方便之後做trace code\n因定期程式時間頻率高，一個工作內，還有併發，需做好log檔案管理，否則之後很難debug\n實際問題 在APScheduler定時任務中，一個job預設是一個主線程任務，當其中一個主線程併發的子線程任務要分類回該主線程的紀錄檔案內，要如何做到？\n主要程式邏輯 第一步 對入口點建立logger 第二步 進入主要線程，加入TimedRotatingFileHandler(線程安全) 對主要線程命名，FileHandler檔案名稱 退出主要線程時，關閉FileHandler 第三步 在要併發的線程池，加上主要線程名稱當前綴 線程邏輯 對同類線程做重命名\nLogging邏輯 在FileHandler 加上filter，對線程名稱做分類檢查\n在logging模組中，自定義Filter需繼承logging.Filter與實作介面filter，利用filter回傳true 或 false來判斷，這筆log record需不需要紀錄， 所以可以用把線程名稱當判斷依據，實作分類檢查的可能\nclass LogUtil: ..... @classmethod def start_thread_logging(cls, log_path, file_name): thread_name = threading.Thread.getName(threading.current_thread()) log_handler = cls.__get_file_handler(log_path, file_name) log_filter = ThreadLogFilter(thread_name) log_handler.addFilter(log_filter) logger = logging.getLogger() logger.addHandler(log_handler) return log_handler @classmethod def stop_thread_logging(cls, log_handler): logging.getLogger().removeHandler(log_handler) log_handler.close() class ThreadLogFilter(logging.Filter): def __init__(self, thread_name, *args, **kwargs): logging.Filter.__init__(self, *args, **kwargs) self.thread_name = thread_name def filter(self, record): return self.thread_name in record.threadName def main() log init ... APScheduler add_job.. def job(): thread_name = \u0026quot;job_name\u0026quot; threading.current_thread().name = thread_name log_handler = LogUtil.start_thread_logging(log_path=..., file_name=...) do_job(thread_name) LogUtil.stop_thread_logging(log_handler=log_handler) def do_job(thread_name): ... with ThreadPoolExecutor(thread_name_prefix=thread_name) as executor: for item in rows: executor.submit(work) ","pubDate":"2023-09-16","title":"Python Logging 在多線程進階應用"},{"link":"https://hanksky12.github.io/posts/2023-08-12-courage_to_be_hated/","plain":"被討厭的勇氣:自我啟發之父「阿德勒」的教導 第一章: 決定論:亞里斯多德 過去的原因造成現在的我\n目的論:阿德勒 我想達成的目的造成現在的我\n重點不在經歷什麼，而是如何賦予這段經歷對自己的價值\n無論過去發生的事，對將來要如何生活是完全沒影響的\n第二章: 煩惱來自人際關係 孤獨: 在身邊的團體將自己排除在外，才會感受孤獨，非自己一個人就是孤獨\n自卑: 是主觀的自我認定\n不幸: 把自己的不幸當成支配他人的工具，那就會沈浸在不幸的狀態\n權力鬥爭: 憤怒是一種工具，不要去依賴\n承認錯誤、表達歉意、脫離權力鬥爭都不是挫敗\n人生任務: 工作、交友、愛\n第三章: 割捨別人的課題 課題區分的方法 決定的結果是誰來承擔？\n人生課題 選擇自認為最好的一條路，別人的評論是別人的課題，不需去干預 不要介入他人的課題，也不要讓他人介入你的\n認同課題 不要去尋求他人的認同，否則最後過的是他人的人生，別人也不是為了滿足我的期望而活\n自由=\u0026gt;被討厭的勇氣 被別人討厭才是真正的依照自己的意志自由的活著的證據 無法不在意他人評價、無法不害怕被討厭、不想付出不被認同的代價，就無法貫徹自己的生活方式\n第四章: 社會意識 把別人當夥伴(不是敵人)，感覺到自己的歸屬\n別人怎麼看我 會在乎這問題的人，其實是以自我為中心，只關心自我的人\n橫向關係vs縱向關係 稱讚與責備都是縱向關係的用語，人際關係應該都是橫向關係，只要表達鼓勵即可(「謝謝」)\n自我的價值 主觀的認知我對別人是有貢獻，就能感受到自己的價值(不是去迎合他人的期望)\n價值 取決一個人的存在，而不是一個人的行為(像是長輩只要還活著，對我就是一種價值)\n第五章: 接納自我vs肯定自我 接納自己的不擅長與缺點，肯定自我是暗示自己一定做得到是欺騙自己的生活方式\n\u0026lt;寧靜禱文\u0026gt; 賜給我平靜的心，去接納無法改變的事物 賜給我勇氣，去改變可以改變的東西 賜給我智慧，去分辨兩者的差別 信任 害怕信任，將無法建立深厚的關係，破裂時痛苦較少，但也無法獲得更多的喜悅\n工作的本質 做出對他人的貢獻，實際是為了感受我的價值\n工作狂 逃避人生的其他責任，以自己的行為定義自己的價值，當退休後，無法生產，會嚴重打擊自己的觀念\n甘於平凡的勇氣 不是所有人都是特別好的那群，但也不要為了得到他人關注，去做特別的存在(簡便的追求卓越)，平凡不是無能\n人生 不是一條線，而是多個當下斷點，每個點都可能是終結的點\n沈溺過去、張望未來，使自己的人生都在微弱的燈光下，以為自己掌握了，無視於「當下」，才是最大的謊言 ","pubDate":"2023-08-12","title":"被討厭的勇氣"},{"link":"https://hanksky12.github.io/posts/2023-07-16_rpa/","plain":"RPA 機器流程自動化，以程式模擬人類操作系統，去取代人工達成自動化\n白話:能自動打怪的外掛\n為何能存在 當公司內部有多系統，之間需要交流資訊，而系統都非自建，RPA是一種不錯的膠水，因不可能把所有系統重一整套， 資料庫如果也不開放外部連入，或者即使能連入，不敢確定程式如何與表連動，直接對底層做寫入，可能有異常問題， 那這種方式是一種選擇\n機緣 工作上剛好需要我需要將資料放入一個ERP系統，因為有使用selenium做爬蟲，其實也類似對網站自動化抓取， 於是一開始用python做RPA，發現有很多困難點，是爬蟲不會遇到的，尤其我要做的是全自動，人工完全不介入\n難點 非侵入式的操作系統 有沒有遇到問題，程式本身不會知道，即使查詢log，也無法直接看出問題， 因為系統不會跟你的程式互動(至少爬蟲還有瀏覽器的反饋)， 就像瞎眼讓你打鍵盤，解決方法就是加上眼睛，以非傳統方式紀錄，協助判斷問題\n大量的畫面判斷 要以畫面定位方式，確認按鈕位置或數字\n當系統改變就要立刻改變RPA程式 這一點跟爬蟲類似，依附在別人的系統上，要隨即應變\n工作後期: 發現以python做開發速度真的太慢，尤其做畫面判斷，自己需要做圖片定位，對圖片數字判斷後期壓到2~5趴錯誤率，還是覺得不好用， 後來學習UiPath，國外成熟的RPA軟體，開發速度才快又穩定\n個人看法: 與資料庫溝通，是資料存取最準確的方式，真的沒辦法再採用這種間接的方式，這個方式有一個很大的缺點，就是速度，當工作量大時， 只能多開電腦並行操作系統，也必須卡在模擬操作的繁複性，以資源與時間利用率觀點是很浪費\n如果能對資料庫操作，只要一台電腦，跑多進程或多線程，就能以更佳的方式解決，但在工作方式上，還是不失為解決問題的一種手段\n","pubDate":"2023-07-16","title":"RPA，過去工作經驗分享"},{"link":"https://hanksky12.github.io/posts/2023-06-24_python%E8%88%87c#%E8%A8%98%E6%86%B6%E9%AB%94%E6%AF%94%E8%BC%83/","plain":"Python 基礎: 變數本身只有存參考地址（在Stack），物件全部都在Heap，變數只有指向作用，所以沒有任何型別問題， 不一樣的變數，只是將地址指向不同的物件，所以是動態語言，到底變數是什麼型態，在執行期才會確定\n分為mutable 與 Immutable，區分方法為當變數想要改變參考的物件的值，會不會改變數存的參考地址\nImmutable 當一個物件值，要換值，需要換原本變數內的地址（把變數存新創物件的地址） mutable 物件的值存的是指向其他物件的地址，所以要改變物件值不會影響到變數內存的物件參考地址 C# 基礎: 分為value type與reference type，區分方法為在Stack的變數裡面存的是值還是地址\nvalue 變數直接在Stack存值（宣告一定的記憶體空間，不能改變） reference 變數類似python存地址，去指向在Heap創造的物件 ","pubDate":"2023-06-24","title":"Python與C#記憶體比較"},{"link":"https://hanksky12.github.io/posts/2023-06-24_pool/","plain":"What is Pool ? 一個用來管理某種資源，保持某個狀態，降低反覆創建資源的開銷，當你需要使用時，就到Pool拿取，用完就放回去，所以池裡會有多個資源閒置狀態\nWhere is Pool? Connection pool(資料庫的client、server的連線池) 每次的連線需要反覆的創建connect，用完就關閉是一種消耗，所以用池來保持一定的連線數量\n進程池、線程池 每次要開多進程、線程，要反覆的創建與消滅，不如保持一定的數量，直接調用\nWhat can Pool do ? 降低運行的消耗 拿已有的資源比創建資源快 通常可設定最大、最小數量、空閑保持的基本數量細力度的控制 How can we use Pool ? 當你發現會大量創造與結束某個資源的時候，就可以使用， 反之，你偶爾才用一次，那平常維持一個Pool在那邊，是一種無形的浪費\n","pubDate":"2023-06-24","title":"Pool池的概念"},{"link":"https://hanksky12.github.io/posts/2023-06-17_hugo/","plain":"安裝hugo 下載theme 設定config.toml\n⇒ hugo new \u0026quot;posts/first-post.md\u0026quot;\n⇒ hugo new \u0026quot;about/_index.md\u0026quot;\ndraft = false 才是從草稿變成要發布的網頁\nrun server ⇒ hugo server -D\nhugo 生成後網頁檔案在public\n佈置到github 先到github 新增項目 your_user_name.github.io 必須是這個名字\n第一次init 與設定 my-blog % cd public public % git init # 初始化仓库 public % git remote add origin https://github.com/你的Github账号名/你的Github账号名.github.io.git # 链接远程仓库 public % git add . public % git commit -m \u0026#34;first commit\u0026#34; public % git push -u origin main 之後的push my-blog % hugo my-blog % cd public public % git add . public % git commit -m \u0026#34;new commit\u0026#34; public % git push 本地圖片上傳 在static建立資料夾img，放入圖片wechat.png\nmy-blog % hugo my-blog % hugo server 圖片資料夾就會複製到public下面，提供網站使用 在markdown輸入 ![](/img/wechat.png) 就能連接到此圖片 在md使用Shortcode(模板可寫簡易程式) 在layouts/shortcodes建立shortcode.html\n在md使用 { { \u0026lt; shortcode \u0026gt; } } 就能使用 ","pubDate":"2023-06-17","title":"Hugo架站紀錄"},{"link":"https://hanksky12.github.io/posts/2023-06-17_dp_memento/","plain":"Memento-備忘錄模式 分類 行為模式-Behavioral Patterns\n主要角色 Originator、Memento、Caretaker\n目的 將Originator的部分狀態做儲存，可以做狀態回朔\n如何互動 在Originator內部，將狀態記錄到Memento生成物件，交由Caretaker管理，在需要的時候， 從Caretaker拿回Memento回復到之前紀錄\nGitHub練習 https://github.com/hanksky12/DesignPatterns/tree/main/Memento\n實務上 未運用過，沒經驗可分享\n","pubDate":"2023-06-17","title":"設計模式-備忘錄模式"},{"link":"https://hanksky12.github.io/posts/2023-06-17_dp_templatemethod/","plain":"Template Method-樣板模式 分類 行為模式-Behavioral Patterns\n主要角色 Abstract Class、Concrete Class1、Concrete Class2\n目的 提出共同流程到Abstract Class，避免重複程式碼\n如何互動 在Abstract Class定義整個演算法流程，並實現部分方法，將特定方法留到Concrete Class再去實作\nGitHub練習 https://github.com/hanksky12/DesignPatterns/tree/main/TemplateMethod\n實務上 在寫程式中，沒特別學習，自然而然就實現的模式，類似於小學數學的提出最大公因數\n","pubDate":"2023-06-17","title":"設計模式-樣板模式"},{"link":"https://hanksky12.github.io/posts/2023-05-31_otp/","plain":"源起 最近自己在很多地方的登入都需要2FA驗證，先用手機裝驗證軟體掃ＱRCode，之後的每次登入都要輸入6位數字， 一直沒搞懂原理，但又覺得很酷，剛好最近要做一個python私人用的密碼管理程式，就在想能不能結合這個東西來驗證， 以下就是自己理解後名詞的介紹\n實作的Github https://github.com/hanksky12/Personal-Password-Manager\nMFA(Multi-Factor Authentication) 除了密碼之外，在登入時有其他驗證須通過就可以稱為多重驗證(多因子驗證)\n例子：輸入手機收到的簡訊數字、線上銀行ATM提款卡、手機TOTP的六位數字\n2FA MFA的特例，兩種驗證就是2FA，以此類推\nOTP(One Time Password) 一次性驗證碼，用完就丟，只能用一次，其中有名的演算法是HOTP和TOTP\nHOTP(HMAC-based) HMAC雜湊訊息驗證碼 RFC4226\nHOTP(K,C) = Truncate(HMAC-SHA-1(K,C)) C 8-byte counter value, the moving factor. This counter MUST be synchronized between the HOTP generator (client) and the HOTP validator (server). K shared secret between client and server; each HOTP generator has a different and unique secret K. 白話文： 用一串key string 加上 counter計數器，做Hash之後，取特定位數做比對\n實作： 產出器將key傳到比對器之後，兩邊各自跑counter計數器，看最後出來的值是否一致\n兩邊各自跑counter，所以可能有前後落差要處理 最後只取特定位數 ，所以要限制比對次數，避免被大量嘗試攻擊 重點在key必須隱蔽的傳到對方的比對器，不能外流 TOTP(Time-based) HOTP的特化版，counter計數器使用timestamp\nwhy 30秒? 必然server跟手機不可能時間永遠同步， 在兩邊跑出來的結果可能有落差，通常使用30秒才換一次， 來容納兩邊的時間不同步，否則驗證失敗可能性太高，server壓力太大，\nwhy 6位數? 6位數，是一百萬組可能性，需在30秒內嘗試完成，每秒要驗證3.3萬次，server後台可以藉此鎖定黑名單\nQRCode 用來傳遞key string，所以要確保隱蔽，通常網站讓你掃完就會消失，無法存檔，確保只有你的手機有這個key\npython實作套件 import pyotp #限制base32的key才能使用 _otp = pyotp.TOTP(base32_key) 參考資料 https://en.wikipedia.org/wiki/Time-based_one-time_password\nhttps://fullstackladder.dev/blog/2017/09/07/one-time-pass-introduce-with-hotp-totp-google-authenticator/\nhttps://medium.com/starbugs/totp-2fa-algorithm-in-10-mins-25acc3c35df9\n","pubDate":"2023-05-31","title":"MFA與OTP"},{"link":"https://hanksky12.github.io/posts/2023-05-18_hello_world/","plain":"Hello World!\n就像每次學習新的語言， Hello world都是第一個印在console的字眼，\n記得\n第一次學習\u0026gt;程式語言-Python\n第一次學習\u0026gt;處理資料語言-R\n第一次學習\u0026gt;靜態編譯語言-C#\n第一次學習\u0026gt;前端語言-Js\n第一次學習\u0026gt;網站語言-Php\n第一次學習\u0026gt;簡體語言-易\n第一次學習\u0026gt;帶指針語言-Golang\n待續\u0026hellip;\n第一次學習\u0026gt;關聯資料庫-MySQL\n第一次學習\u0026gt;後端框架-Flask\n第一次學習\u0026gt;前端框架-Vue\n第一次學習\u0026gt;訊息貯列-RabbitMq\n第一次學習\u0026gt;任務貯列-Celery\n第一次學習\u0026gt;非關聯資料庫-MongoDB\n第一次學習\u0026gt;大型訊息貯列-Kafka\n第一次學習\u0026gt;記憶體資料庫-Redis\n待續\u0026hellip;\n","pubDate":"2023-05-18","title":"Hello World"}];
    var search_theEnd = "The End";
    var search_nothing = "Nothing was found";
    var search_found = "Found";
    var search_result = "result";
    var search_results = "results";
    var enable_mermaid =  null 
</script>





        
    </body>
</html>

